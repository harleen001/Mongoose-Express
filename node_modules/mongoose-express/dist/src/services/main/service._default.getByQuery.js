"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const wrapperFindOptions_1 = __importDefault(require("../../classes/wrapperFindOptions"));
const service__default_helpers_runAllMiddleware_1 = __importDefault(require("./service._default.helpers.runAllMiddleware"));
const service__default_helpers_query_1 = require("./service._default.helpers.query");
const service__default_helpers_runAllPostprocessing_1 = __importDefault(require("./service._default.helpers.runAllPostprocessing"));
const getTransaction_1 = __importDefault(require("../sentry/getTransaction"));
const errorWithCode_1 = require("../../classes/errorWithCode");
exports.default = (model, options = {}, existingTransaction) => async (query) => {
    const transaction = (0, getTransaction_1.default)({
        name: 'service._default.getByQuery',
        op: 'service.run',
        data: {}
    }, existingTransaction);
    const opts = new wrapperFindOptions_1.default(options);
    query = (0, service__default_helpers_query_1.mergeQuerySelector)(query, opts.options.initialQuery);
    await service__default_helpers_runAllMiddleware_1.default.find(query, opts, transaction);
    const spanFind = (0, getTransaction_1.default)({
        name: 'model.find',
        data: {
            modelName: model.name,
            query
        }
    }, transaction);
    const doc = model.find(query, null, opts.mongooseModel);
    opts.options.exclude.forEach((exclude) => doc.select(`-${exclude}`));
    opts.options.populateFields.forEach(field => doc.populate(field));
    if (opts.options.sort)
        doc.sort(opts.options.sort);
    if (opts.options.skip)
        doc.skip(opts.options.skip);
    if (opts.options.limit)
        doc.limit(opts.options.limit);
    opts.options.populateFields.forEach(field => doc.populate(field));
    try {
        const spanExec = (0, getTransaction_1.default)({
            name: 'document.exec',
            op: 'document.exec',
            data: {
                query,
            }
        }, spanFind);
        const populatedDocs = await doc.exec();
        spanExec.finish();
        spanFind.finish();
        const spanMapPopulatedDocs = (0, getTransaction_1.default)({
            name: 'service._default.getByQuery.mapPopulatedDocs',
            op: 'service.run.sub'
        }, transaction);
        const objects = populatedDocs.map(pd => pd.toObject());
        spanMapPopulatedDocs.finish();
        await service__default_helpers_runAllPostprocessing_1.default.find(objects, query, opts, transaction);
        return objects;
    }
    catch (err) {
        throw new errorWithCode_1.ErrorUnauthorized({ message: 'Not authorized' });
    }
    finally {
        transaction.finish();
    }
};
//# sourceMappingURL=service._default.getByQuery.js.map